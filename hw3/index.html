<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184/284A Pathtracer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>



<body>

<h1 align="middle">CS 184/284A: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Homework 3: Pathtracer</h1>
<h2 align="middle">Sriteja Vijapurapu</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>In this homework, I implemented various techniques for illuminating surfaces and objects for realistic lighting. Some methods include ray tracing, hemisphere sampling, and more. Note: AI tools were used to gain a deeper understanding of the underlying principles behind the concepts and how to approach implementation for a few tasks.</p>

<h2 align="middle">Section I: Ray Generation and Scene Intersection </h2>

<h3 align="middle">Ray Generation</h3>
	<p>For ray generation, I applied basic Monte Carlo integration over ns_aa randomly sampled rays passing through the neighborhood of the pixel. Rays were generated after normalizing and illuminated through the global illumination helper function. This works by essentially estimating the integral over a certain domain, which in this case is the immediate surroundings of the pixel, and provides accurate illumination.
	</p>
<h3 align="middle">Intersection</h3>
	<p>
		Ray-triangle intersection was performed by implementing the Möller-Trumbore algorithm. I first found the 2 edge vectors corresponding to a particular vertex, then computed the determinant with the edge and the normal to the edge and ray. This is useful in checking whether or not the ray is parallel to the triangle, in which case they will never intersect. Then, I computed barycentric coordinates, which, if outside of certain ranges depending on the vertex, show there are no intersections. The intersection point is found through the dot product of an edge and the corresponding barycentric coordinate. Finally, we double check the point is valid according to the timestep based on the bounds we have.
		Below are some images of files with normal shading.
	</p>
	
<div style="text-align: center;">
  <table style="width: 100%; margin-left: auto; margin-right: auto;">
    <tr>
      <td>
        <img src="task11.png" width="400px"/>
        <figcaption>Spheres</figcaption>
      </td>
      <td>
        <img src="task12.png" width="400px"/>
        <figcaption>Bunny</figcaption>
      </td>
      <td>
        <img src="task13.png" width="400px"/>
        <figcaption>Gems</figcaption>
      </td>
    </tr>
    <tr>
      <td>
        <img src="task14.png" width="400px"/>
        <figcaption>Cow</figcaption>
      </td>
    </tr>
  </table>
</div>



<h2 align="middle">Section II: Bounding Volume Hierarchy</h2>

<h3 align="middle">BVH Consutrction</h3>
  <p>
	  For constructing the BVH tree, I went with a recursive approach, first checking the standard base case of whether or not we are at a leaf node. For the heuristic, along each axis, I computed the value of the left box’s surface area multiplied by the number of primitives on the left and added that with the value of the right box’s surface area multiplied by the number of primitives on the right side. Whichever was minimal was the axis I chose. I split into left and right boxes based on the average centroid position. I then recursed down the left and right subtrees based on the split from the heuristic. An interesting issue I ran into was pointer problems when performing the recursive call. The pointers to the vectors storing the primitives would get lost in the stack, causing my code to error. I asked ChatGPT how to fix this, and it recommended some C++ specific in-line function that addressed the problem without altering any dependencies. This was the partition function.
	  
  </p>

  <div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="task21.png" align="middle" width="600px"/>
        <figcaption align="middle">Max Planck</figcaption>
      </td>
      <td>
        <img src="task22.png" align="middle" width="600px"/>
        <figcaption align="middle">Beast</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="task23.png" align="middle" width="600px"/>
        <figcaption align="middle">Car</figcaption>
      </td>
      <td>
        <img src="task24.png" align="middle" width="600px"/>
        <figcaption align="middle">Building</figcaption>
      </td>
    </tr>
  </table>
</div>


<p>The rendering times of images such as Max Planck, the beast, and beetle, on average, took about 1.2 seconds. On the other hand, without BVH acceleration, the max planck image alone took nearly 2 minutes on my local machine. The building.dae file is another example, rendering almost instantly while taking minutes to render without the acceleration algorithm.
</p>




<h2 align="middle">Section III: Direct Illumination</h2>
	<p>I implemented the Loop subdivison algorithm by first finding the positions of the new and old vertices, iterating around every vertex and each halfedge about each of those vertices. I then applied the formula for the updated position for the old vertex according to the spec. For the edges, I followed a similar approach by iterating over every edge of the mesh and finding the appropriate values to update. I then did the standard flipEdge and splitEdge over the proper edges. In this case, split every edge and flip an edge connecting an old and new vertex. An interesting debugging trick I used was to implement each step of the algorithm individually, and see the effect of it on the mesh. For instance, I first applied the splitEdge, then flipEdge, and then combined them to not only learn about the effects of each on the entire mesh, but also to make sure the implementation was correct. Sharp edges tend to smooth out, and cubes become much more spherical. Pre-splitting edges would probably lower the effect since they aren’t explicitly accounted for on each run. It doesn’t consider sharpness unless specifically done.</p>
<p>Below are images of Loop subdivision steps performed on both the cube and the torus.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="task6cube1.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
      <td>
        <img src="task6cube2.png" align="middle" width="400px"/>
        <figcaption align="middle">.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="task6cube3.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
      <td>
        <img src="task6cube4.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
    </tr>
  </table>
</div>


<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="task6torus1.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
      <td>
        <img src="task6torus2.png" align="middle" width="400px"/>
        <figcaption align="middle">.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="task6torus3.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
      <td>
        <img src="task6torus4.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
    </tr>
  </table>
</div>
</body>
</html>
