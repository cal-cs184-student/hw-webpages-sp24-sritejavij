<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184/284A Pathtracer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>



<body>

<h1 align="middle">CS 184/284A: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Homework 3: Pathtracer</h1>
<h2 align="middle">Sriteja Vijapurapu</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>In this homework, I implemented various techniques for illuminating surfaces and objects for realistic lighting. Some methods include ray tracing, hemisphere sampling, and more. Note: AI tools were used to gain a deeper understanding of the underlying principles behind the concepts and how to approach implementation for a few tasks.</p>

<h2 align="middle">Section I: Ray Generation and Scene Intersection </h2>

<h3 align="middle">Ray Generation</h3>
	<p>For ray generation, I applied basic Monte Carlo integration over ns_aa randomly sampled rays passing through the neighborhood of the pixel. Rays were generated after normalizing and illuminated through the global illumination helper function. This works by essentially estimating the integral over a certain domain, which in this case is the immediate surroundings of the pixel, and provides accurate illumination.
	Below are some normal shading images.</p>
	
<div style="text-align: center;">
  <table style="width: 100%; margin-left: auto; margin-right: auto;">
    <tr>
      <td>
        <img src="task11.png" width="400px"/>
        <figcaption>Spheres</figcaption>
      </td>
      <td>
        <img src="task12.png" width="400px"/>
        <figcaption>Bunny</figcaption>
      </td>
      <td>
        <img src="task13.png" width="400px"/>
        <figcaption>Gems</figcaption>
      </td>
    </tr>
    <tr>
      <td>
        <img src="task14.png" width="400px"/>
        <figcaption>Cow</figcaption>
      </td>
      <td>
        <img src="task15.png" width="400px"/>
        <figcaption></figcaption>
      </td>
      <td>
        <img src="task16.png" width="400px"/>
        <figcaption></figcaption>
      </td>
    </tr>
  </table>
</div>

<div align="center">
  <img src="task1withcurve.png" width="400px"/>
  <figcaption>The completed curve with my interpolation.</figcaption>
</div>

<div align="center">
  <img src="task1diffcurve.png" width="400px"/>
  <figcaption>A different curve interpolated.</figcaption>
</div>

<div align="center">
  <img src="task1diffcurvemousscroll.png" width="400px"/>
  <figcaption>The curve interpolated with a different t parameter.</figcaption>
</div>

<h3 align="middle">Intersection</h3>
<p>Ray-triangle intersection was performed by implementing the Möller-Trumbore algorithm. I first found the 2 edge vectors corresponding to a particular vertex, then computed the determinant with the edge and the normal to the edge and ray. This is useful in checking whether or not the ray is parallel to the triangle, in which case they will never intersect. Then, I computed barycentric coordinates, which, if outside of certain ranges depending on the vertex, show there are no intersections. The intersection point is found through the dot product of an edge and the corresponding barycentric coordinate. Finally, we double check the point is valid according to the timestep based on the bounds we have.
</p>
  
  <div style="text-align: center;">
  <img src="task2.png" width="600px"/>
  <figcaption>An evaluation of the algorithm on a teapot.</figcaption>
</div>

<h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>

<h3 align="middle">Part 3: Area-Weighted Vertex Normals</h3>
  <p>To implement the area-weighted vertex normals, I traversed the faces about a vertex similar to how it is described in the halfEdgeMesh.h. Then, I found the area-weighted face normals for each face by just using the basic cross-product definition and summed and normalized them.</p>

  <div align="center">
  <table style="width:100%">
    <tr>
      <td align="center">
        <img src="task3noq.png" width="400px"/>
        <figcaption>Teapot shading without vertex normals.</figcaption>
      </td>
      <td align="center">
        <img src="task3q.png" width="400px"/>
        <figcaption>Teapot shading with vertex normals.</figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 align="middle">Part 4: Edge Flip</h3>
<p> To implement edge flips, I first drew out the triangle diagram given in the spec. Then, by following the vertices and edges of each, I mapped each to the corresponding position, and then just hard-coded out each of the new positions. Debugging was pretty nitpicky, since small changes to outer twin edges, or twin->next()’s, etc. all impacted the entire code, so each line had to be both purposeful and in order since subsequent lines depended on the previous ones. </p>

  <div align="center">
  <table style="width:100%">
    <tr>
      <td align="center">
        <img src="task4.png" width="400px"/>
        <figcaption>The teapot after a few edge flips.</figcaption>
      </td>
      <td align="center">
        <img src="task4-2.png" width="400px"/>
        <figcaption>The teapot after a few other edge flips.</figcaption>
      </td>
    </tr>
  </table>
</div>
  
<h3 align="middle">Part 5: Edge Split</h3>
<p>In order to implement edge splitting, I first drew out the basic triangle, labeling all the halfedges, edges, vertices, twins, and more that I needed to keep track of. I converted the initial BC edge into one of the 4 total new edges that were in the end result. I followed the spec and just created a new middle vertex in the center and updated all the variables I stored around it based on what the new neighbors were. An interesting debugging trick I used was to first just write down and code up every single edge, vertex, twin, halfedge, face, and everything into their own variables. Then, after reassigning everything, I deleted what ended up not being necessary until I was left with what worked. This helped a lot since instead of trying to figure out what I was missing, I was able to systematically eliminate unnecessary updates until I was left with a working result.</p>
  <div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="task51.png" align="middle" width="600px"/>
        <figcaption align="middle">The teapot after some edge splits.</figcaption>
      </td>
      <td>
        <img src="task52.png" align="middle" width="600px"/>
        <figcaption align="middle">The teapot after some edge splits.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="task53.png" align="middle" width="600px"/>
        <figcaption align="middle">The teapot after a combination of edge splits and flips.</figcaption>
      </td>
      <td>
        <img src="task54.png" align="middle" width="600px"/>
        <figcaption align="middle">The teapot after a combination of edge splits and flips.</figcaption>
      </td>
    </tr>
  </table>
</div>


<h3 align="middle">Part 6: Loop Subdivision for Mesh Upsampling</h3>
	<p>I implemented the Loop subdivison algorithm by first finding the positions of the new and old vertices, iterating around every vertex and each halfedge about each of those vertices. I then applied the formula for the updated position for the old vertex according to the spec. For the edges, I followed a similar approach by iterating over every edge of the mesh and finding the appropriate values to update. I then did the standard flipEdge and splitEdge over the proper edges. In this case, split every edge and flip an edge connecting an old and new vertex. An interesting debugging trick I used was to implement each step of the algorithm individually, and see the effect of it on the mesh. For instance, I first applied the splitEdge, then flipEdge, and then combined them to not only learn about the effects of each on the entire mesh, but also to make sure the implementation was correct. Sharp edges tend to smooth out, and cubes become much more spherical. Pre-splitting edges would probably lower the effect since they aren’t explicitly accounted for on each run. It doesn’t consider sharpness unless specifically done.</p>
<p>Below are images of Loop subdivision steps performed on both the cube and the torus.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="task6cube1.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
      <td>
        <img src="task6cube2.png" align="middle" width="400px"/>
        <figcaption align="middle">.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="task6cube3.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
      <td>
        <img src="task6cube4.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
    </tr>
  </table>
</div>


<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="task6torus1.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
      <td>
        <img src="task6torus2.png" align="middle" width="400px"/>
        <figcaption align="middle">.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="task6torus3.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
      <td>
        <img src="task6torus4.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
    </tr>
  </table>
</div>
</body>
</html>
