<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184/284A Rasterizer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>



<body>

<h1 align="middle">CS 184/284A: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Homework 1: Rasterizer</h1>
<h2 align="middle">Sriteja Vijapurapu</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>In this homework, I implemented a variety of basic graphics techniques, including rasterization, supersampling, barycentric interpolation, and more. </p>

<h2 align="middle">Section I: Rasterization</h2>

<h3 align="middle">Part 1: Rasterizing single-color triangles</h3>
<p>In order to rasterize the triangles, I first found the bounding box by computing the minimum and maximum X and Y coordinates of the triangle based on its vertices. Then, I just iterate through the box and determine whether or not each point is inside the triangle using the cross-product formula (if the signs of all the cross-products are the same, the point is inside the triangle). It’s no worse than checking each sample within the bounding box since this is exactly what my algorithm does.</p>
<div align="center">
  <img src="task1.png" width="400px"/>
  <figcaption>Default viewing parameters for test4, zoomed in on the edge of a triangle.</figcaption>
</div>
<!-- 
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="task1.png" align="middle" width="400px"/>
        <figcaption align="middle">Default viewing parameters for test4, zoomed in on the edge of a triangle.</figcaption>
      </td>
      <td>
        <img src="images/image2.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images/image3.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
      <td>
        <img src="images/image4.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
    </tr>
  </table>
</div> -->


<h3 align="middle">Part 2: Antialiasing triangles</h3>
<p>Supersampling is useful because it allows us to capture a significantly more detailed representation of the image by blowing it up and shrinking it back in.
  To implement this, I first increase the rendered resolution with sample_rate. Since we divide each pixel into sqrt(sample_rate) segments, this is what the multiplication is with. 
  Then, using the coordinates in the supersampled positions (superX, superY), I converted this back into the regular, non-supersampled coordinates (sampleX, sampleY) and centered this. 
  This is noted by the variables (centerX, centerY). Then, we apply a similar approach to task 1 to determine whether or not the centered pixel coordinates are inside the triangle or not. 
  If it is inside, the color is marked in the sample_buffer array. </p>
  
  <div align="middle">
  <table style="width:100%">
    <tr>
      <td align="center" colspan="2">
        <img src="task2-1supersample.png" width="400px"/>
        <figcaption>Supersampling rate of 1.</figcaption>
      </td>
    </tr>
    <tr>
      <td align="center">
        <img src="task2-16supersample.png" width="400px"/>
        <figcaption>Supersampling rate of 16.</figcaption>
      </td>
      <td align="center">
        <img src="task2-4supersample.png" width="400px"/>
        <figcaption>Supersampling rate of 4.</figcaption>
      </td>
    </tr>
  </table>
</div>
  <p>The results are more dramatic near a skinny corner because the pixel coverage in these areas are inherently small, and increasing the resolution here leads to the largest disparity from the initial sample.</p>
  
  
<h3 align="middle">Part 3: Transforms</h3>
<p>Here, I implemented basic matrix transforms, such as translate and rotate. I altered the svg file of the robot to make it look like it is waving.</p>
  
<div align="center">
  <img src="task3.png" width="400px"/>
  <figcaption>Robot waving after transforming the limbs.</figcaption>
</div>

<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 4: Barycentric coordinates</h3>
  <p>Barycentric coordinates are a coordinate system in which each point is a linear combination of the vertices on a triangle. In other words, it’s a way of relating each point inside the triangle to each of the vertices in some scalable, understandable way. This is especially helpful with color gradients because we have a smooth way of interpolating the interior of a shape based on their relative position to each of the vertices’ colors. The cut-up circle shows how it’s still able to smoothly interpolate the color across sharp corners.
</p>

  <div align="center">
  <table style="width:100%">
    <tr>
      <td align="center">
        <img src="task4copy.png" width="400px"/>
        <figcaption>A sample rate of 1 with default viewing parameters.</figcaption>
      </td>
      <td align="center">
        <img src="task4.png" width="400px"/>
        <figcaption>A chopped-up circle into triangle pieces showing smooth color interpolation in sharp areas.</figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>
Pixel sampling is a method by which we can attach textures to our graphics. It samples pixels from the texture and finds how to map it to our surface. Nearest neighbor sampling is a method in which we select the nearest texel color on the texture relative to where we are on the surface. There’s no interpolation. Bilinear sampling, on the other hand, is a bit more involved. It takes the four closest texels and and interpolates the colors across the four of these to arrive at the color displayed on the surface. This allows for a much smoother surface in terms of its color interpolation. There will be a larger difference when there are finer details in the texture, where nearest_neighbor will end up slightly blurrier or less exact as billinear. 

  

  
<h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>



<h2 align="middle">Section III: Art Competition</h2>
<p>If you are not participating in the optional art competition, don't worry about this section!</p>

<h3 align="middle">Part 7: Draw something interesting!</h3>

</body>
</html>
